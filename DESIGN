KDE Screen Management is designed to be cross-platform from the begining, we are not aiming to
support Windows or Mac (they already have their screen management) but instead we must be sure
that we will be able to support the different Linux technologies that are present nowdays or the
ones that will appear in the future (X, Wayland, NVidia...).

The low level bits are un-abstractable, each technology export different kind of information for
example while XRandR give us stuff like "CRTC" Nvidia will only give us some high level info via
a binary executable called nvidia-sttings.

But everything is not lost, we can still create an abstraction the only thing we have to do is to
find something in common between all possible technologies out there, and we call such thing the
Screen Configuration.

No matter which underneath technology your setup is using, it will always support things like:

· Resolutions
· Rotations
· Cloned screens
· Extended Desktop (screens side by side)
· Custom modes...

So, instead of abstracting how graphics work we are going to have object(s) representing how your
screens are setup or are going to be setup.

This objects will travel through our architecture until they reach the code where they will be
translated into per-platform instructions, for example in case of XRandR the sytem will use
libxrandr while with NVidia we will use nvidia-settings.

The architecture should look as follow:

QRandR:
    -QRandR is a wrapper above xrandr adding only Qish api but NOT abstracting XRandR specifics,
    so if for enabling an Outut you have to "assign" a CRTC to it you will stil have to, the
    difference is that instead of doing something like

    XRRSetCrtcConfig(display, resources, crtcID, tiomestamp , x, y, modeID, RR_Rotate_0, outputs2, outupts2.count);

    you will be able to do something like:
    CrtcConfig config;
    config.setX(x)
    config.setY(y)
    config.setMode(output->mode())
    config.setOutput(output)
    Crtc->setConfig(config);

    API not final.

    Due to how XRandR works, it makes no sense to try to be smart and only fetch data when
    requested. Instead we will fill the object once instanced.

    We will try to do it in a constant way of possible and without copies.

Config system:
    The config system will work more or less as follow:

    As explained before the only place where we can abstract the api is Configuration, so we will
    have an object with properties as:

    SetConi
    -Outputs
    -Output po
    -primary
    -